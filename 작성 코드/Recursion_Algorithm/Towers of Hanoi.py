def move(no: int, x: int, y: int) -> None:
    # 1번 과정
    if no > 1:
        print(f'시작기둥 : {x}, 중간기둥 : {6-x-y}') 
        move(no - 1, x, 6 - x - y)
        
    # 2번 과정
    print(f'원반 [{no}]을(를) {x}기둥에서 {y}기둥으로 옮깁니다.')

    # 3번 과정
    if no > 1:
        print(f'중간기둥 : {6-x-y}, 최종기둥 : {y}') 
        move(no - 1, 6 - x - y, y)
       


move(3, 1, 3)

""" 해설 : 여기서 중요한 포인트는 '그룹화' 인데 예를 들어 원반의 개수가 3개 이고 시작기둥(1) 에서 최종기둥(3) 으로 옮긴다는 것을 가정하면
    1번 과정 : 가장 큰 원반을 제외한 나머지 2개의 원반을 그룹화 시키고 그룹화 시킨 원반 2개를 시작기둥(1) 에서 중간 기둥(2) 으로 옮긴다.
    2번 과정 : 가장 큰 원반을 시작 기둥(1) 에서 최종 기둥(3) 으로 옮긴다
    3번 과정 : 그룹화 시킨 2개의 원반을 중간 기둥(2) 에서 최종 기둥(3)으로 옮긴다
    이 과정을 반복하는데 원반이 3개인 경우 no = 3 인 경우고 no -1을 해도 2가 된다 즉 n > 1의 경우를 만족 시킴으로 재귀 함수가 발동 되어
    no가 2인 경우의 1,2,3번 과정을 수행한다. 시작 기둥, 중간 기둥, 최종 기둥을 숫자 1,2,3 으로 처음 정해 놨는데 이 위치가 계속 바뀌지만 
    1,2,3번의 정형화된 과정을 통해 본래의 목적을 수행할 수 있다."""


